`timescale 1ns/0.1ns


module tb_cluster_feeder
    #(
        parameter FIFO_WIDTH = 8,
        parameter KERNEL_SIZE = 5,
        parameter MAX_PIXEL_VAL = 10,
    );

    // Signals
    reg clk;
    reg i_pixel[FIFO_WIDTH*8-1:0];
    reg i_new;
    reg i_sel;
    wire o_pixel[KERNEL_SIZE*8-1:0];

    // Clock
    const int clk_freq = 5; //MHz

    initial begin
        clk = 0;
    end

    always #(1/clk_freq) clk = ~clk;


    // DUT (cluster feeder)
    cluster_feeder dut(
        .i_clk  (clk),

        .i_sel  (i_sel),
        .i_new  (i_new),
        
        i_pixel_0 (i_pixel[7:0]),
        i_pixel_1 (i_pixel[15:8]),
        i_pixel_2 (i_pixel[23:16]),
        i_pixel_3 (i_pixel[31:24]),
        i_pixel_4 (i_pixel[39:32]),
        i_pixel_5 (i_pixel[47:40]),
        i_pixel_6 (i_pixel[55:48]),
        i_pixel_7 (i_pixel[63:56]),
        
        o_pixel_0 (o_pixel[7:0]),
        o_pixel_1 (o_pixel[15:8]),
        o_pixel_2 (o_pixel[23:16]),
        o_pixel_3 (o_pixel[31:24]),
        o_pixel_4 (o_pixel[39:32])
    );



    // Testbench

    reg i_curr[FIFO_WIDTH*8-1:0];

    initial begin
        // Reset all signals to 0
        i_pixel = (KERNEL_SIZE*8-1)'h0;
        i_sel = 1'h0;
        i_new = 1'h0;

        @(posedge clk); // first clock cycle to reset

        // Test 1 : load 8 pixels in parallel, then shift until all the 8 input pixels have been seen
        i_pixel = 64'hBEEF50B3BEEF50B3;
        i_curr = i_pixel; // save input for later comparison
        i_sel = 1'b1; // parallel load
        i_new = 1'b1; // pipeline shall load

        for (int i = 0 ; i < 4 ; i++) begin
            @(posedge clk); // 1 clock cycle to output the data

            // check pixels
            if(i_curr[KERNEL_SIZE*8-1 + i*8 : i*8] != o_pixel) begin
                $display("Test 1 failed at i = %d",i);
                $finish(2);
            end

            i_sel = 1'b0; // switch to serial load
            i_new = 1'b0; // pipeline shall shift
        end
            
        $display("Test 1 passed");

        
    end


endmodule